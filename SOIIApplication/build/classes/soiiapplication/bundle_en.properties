# To change this license header, choose License Headers in Project Properties.
# To change this template file, choose Tools | Templates
# and open the template in the editor.

#Main Menu Fixed Phrases
title = Critical Region and Mutual Exclusion Applet
menuName = Main Menu
readableContent = Summary of Concepts
simulation = Simulations
credits = Credits
changeLanguage = Change Language

#Main Menu Insctructional Phrases
selectAnOption = Select an option
readableInst = Acquire some important knowledge
simulationInst = Animated point of view of the subjects
creditsInst = See who is helping you
changeLanguageInst = Go back to Language Menu

#Simulation Window
process1=Process 1 Instructions
process2=Process 2 Instructions
previous=Previous step
next=Next step
back=Go back
currentprocess1=Process 1 is executing
2blocks1=Process 2 blocks process 1
noblocking=No blocking occurred
currentprocess2=Process 2 is executing
1blocks2=Process 1 blocks process 2
nocritical=No process is in its critical region
critical1=Process 1 is in its critical region
critical2=Process 2 is in its critical region
critical1and2=Both processes are in their critical regions
executing=Current Process Executing Is...
criticalRegion=Current Process In Critical Region Is...
blocking=Is A Process Blocking the Other?
Init=Start
withsimulationMenuTitle=Simulation With Mutual Exclusion
withoutsimulationMenuTitle=Simulation Without Mutual Exclusion
randomsimulationMenuTitle=Random Simulation With Mutual Exclusion
noprocess=Processes have ended execution
withstep0=Imagine two processes are running incrementing a single variable in a shared memory location.\nBoth processes want to read from memory and add one to the value.\nSay the value stored in memory is 95. We expect the first process to read the value from memory to read the value 95,\nadd 1 to it and then store 96. Then, the second process should be able to read value 96, add 1 to it and finally store the\nvalue 97 in memory. But how can the two processes' execution be coordinated so the right values are read and stored?
withstep1=This is done by using mutual exclusion, this is, a mechanism that enables only\none process to read/write from a shared memory location at a given time.\nThe first process is selected by the scheduler and starts executing, creating a local variable.
withstep2=Then, due to mutual exclusion, only one process can be at its critical region at a given time.\nAs process 2 is not in its critical region yet, process 1 is able to proceed and access its critical region by "locking" it.
withstep3=However, the scheduler decides its time to let process 2 execute a little bit. So it starts to run and creates a local variable as well.
withstep4=Then, proces 2 tries to move to the next instruction and enter its critical region.\nBut process 1 is already in its critical region, having previously locked it! So process 2 gets blocked.
withstep5=As process 2 was blocked, it is time for process 1 to run again. It is already in its\ncritical region and reads the content from a shared memory location (address 0xF4D9012C), 95,\nstoring it in the local variable.
withstep6=The scheduler decides it process 2's turn again. It tries to enter its critical region again,\nbut because of mutual exclusion, as process 1 is already at its critical region,\nprocess 2 is blocked again.
withstep7=Process 1 then starts to execute again. It adds 1 to the value in the local variable, which has the value 96 now.
withstep8=Process 2 is selected by the scheduler again and starts executing, but, again, it cannot\nadvance as process 1 is still in its critical region. Process 2 gets blocked.
withstep9=Process 1 executes again and writes 96 to the address 0xF4D9012C.
withstep10=Process 2 is selected by the scheduler again and starts executing, but, again, it cannot\nadvance as process 1 is still in its critical region. Process 2 gets blocked.
withstep11=Then, the scheduler chooses process 1 to execute. Process 1 finally leaves its\ncritical region, "unlocking" it and terminating.
withstep12=As process 1 has already finished its execution and has also left its critical region, process 2\ncan advance! It then enters its critical region and "locks" it.
withstep13=Process 2 reads the value stored in the shared memory location (address 0xF4D9012C),\nwhich is 96, and assigns it to its local variable.
withstep14=Process 2 adds 1 to the value in the local variable, which now holds the value 97.
withstep15=Process 2 writes the value 97 to the shared memory location at address 0xF4D9012C.
withstep16=Process 2 then leaves its critical region and "unlocks" it.
withstep17=It then terminates. After the two processes have executed, we have\nvalue 97 stored in address 0xF4D9012C, as we expected.

withoutstep0=Imagine two processes are running incrementing a single variable in a shared memory location.\nBoth processes want to read from memory and add one to the value.\nSay the value stored in memory is 95. If this was a single sequential program, and the processes functions,\nthe value 95 would be read by the first function, incremented and then stored.\nThe value 96 would then be read by the other function and 97 stored.
withoutstep1=We'll now illustrate how things can go wrong if mutual exclusion is not used when two processes\nrunning share a common memory resource. The first process is selected by the scheduler\nand starts executing, creating a local variable.
withoutstep2=Then, the first process reads the value 95 stored in memory at location 0xF4D9012C and keeps it in a local variable.
withoutstep3=But before it can operate on the value,\nthe scheduler decides it is process' 2 turn, and it is allowed to run.
withoutstep4=The second process reads the unaltered value at address 0xF4D9012C, the same value that the first process read (95).
withoutstep5=The scheduler, liking process 2 better than 1, allows it to continue execution.\nThe second process adds one to the value, outputting 96.
withoutstep6=Finally, it stores the value 96 at memory address 0xF4D9012C and finishes its run.
withoutstep7=The scheduler remembers process 1 exists and gives it processor time, resuming its operation.\nSo, it adds one to the value it read even before process 2 started execution (95).
withoutstep8=Lastly, process 1 stores at memory address 0xF4D9012C the value 96, instead of the desired 97...
withoutstep9=...and terminates. Now, instead of having the expected value 97,\nthe memory location 0xF4D9012C has value 96 stored.
randomstep=This simulation involves two processes that share a common memory and execute\nconcurrently. Both of them have non-terminating while loops. The scheduler selects one of them randomly to execute each cycle.\nThis simulation is using the principles of mutual exclusion.



#Did You Know Window
didYouKnowMenuName = Did you know?
didYouKnowInstructional = Here you will find content about the subjects meant to be taught.\nIt is highly recommended to read before whatchin the simulation
didYouKnowBackButton = Back
didYouKnowContent=*** Summary of Concepts ***\n\n1) Race conditions\n\nWhen two or more different processes are using some shared resource and the order in which they use the resource\ninterferes in the final result, we have a race condition. This name is given because the result dependes in which process executes first.\nExample: as illustrated in the simulation without mutual exclusion (in this open educational resource), there is a race condition when\ntwo processes access a shared memory location and there is no mechanism to determine when and how these processes can operate\non the memory location. If a process reads and writes from/to memory while another process is doing the same, the final result can be\ndifferent than the expected!\n\n2) Mutual Exclusion\n\nTo solve the problem of having non-deterministic results due to race conditions, the concept of mutual exclusion was created. When there\nis a mutual exclusion mechanism, only one process has access to shared memory (or another shared resource) at a given time.\nThe study in the Operating Systems course focuses on the understanding and choice of the adequate primitives to guarantee mutual exclusion.\nAn abstraction can be created to interpret the problem of avoiding race conditions: the concept of Critical Region.\n\n3) Critical Region\n\nCritical Region is the part of a program in which shared resources are accessed (for example, shared memory access). To avoid\nrace conditions, different processes mut be guaranteed not to be at their critical regions at the same time. However, to guarantee\na correct and efficient behavior of concurrent processes, some conditions must be satisfied when implementing a mutual\nexclusion mechanism.\n\n4) Necessary Conditions for a Good Mutual Exclusion Solution\n\nThe four conditions are:\n\t1) Two processes can never be simultaneously at their critical regions\n\t2) Nothing can be said about the number and the speed of CPUs\n\t3) Processes outside of their critical regions cannot block other processes\n\t4) No process must wait forever to enter its critical region\n\n5) Implementation of Mutual Exclusion Mechanisms\n\nPrimitives that guarantee the correct behavior of a mutua exclusion solution are called locks, due to the fact that the process using\na resource will not share it, hence "locking" it.Some examples of primitives (not all of them satisfy all 4 conditions above) are:\n\ta) Busy Waiting\n\tb) Disabling Interruptions\n\tc) Lock Variables\n\td) Mandatory COntext Switching\n \te) Petersons's Solution\n\tf) TSL Instruction\n\tg) Sleep and Wakeup\n\th) Semaphores\n\ti) Mutexes\n\tj) Monitors\n\nBIBLIOGRAPHY:\nTanenbaum, Andrew S. (2008). Modern operating systems. Upper Saddle River, NJ: Pearson Prentice Hall. ISBN 0-13-600663-9.

#Credits
creditsMenuName = Credits
creditsBackButton = Back
creditsContent=Authors:                                                     Github Profile\n\nMarcello de Paula Ferreira Costa                             @travoul\nHenrique de Almeira Machado da Silveira                      @henrisilver\nGuilherme Nishina Fortes                                     @GuilhermeNishina\nS\u00e9rgio Yudi Takeda                                           @SergioTakeda\n\n


Open Educational Resource for the course: Operating Systems I SSC-0640\n\n
Institute of Mathematical and Computer Sciences\n\n
University of S\u00e3o Paulo - S\u00e3o Carlos Campus\n\n
Professor: Paulo S\u00e9rgio Lopes de Souza\n\n
June -2015

#ChooseMenu
mutualExclusion = Mutal Exclusion
noMutualExclusion = No Mutual Exclusion
random = Random
backButtonChooseSimulationMenu = Back to main menu
chooseMenuTitle = Choose Simulation Mode
onMutualExclusion=Watch a step-by-step simulation of a monocore system that implements mutual exclusion
onNoMutualExclusion=Watch a step-by-step simulation of a monocore system that does not implement mutual exclusion
onRandom=This simulation tries to emulate a scheduler with a seemingly random decision making
