# To change this license header, choose License Headers in Project Properties.
# To change this template file, choose Tools | Templates
# and open the template in the editor.

#Main Menu Fixed Phrases
title = Critical Region and Mutual Exclusion Applet
menuName = Main Menu
readableContent =About
simulation = Simulation
credits = Credits
changeLanguage = Change Language

#Main Menu Insctructional Phrases
selectAnOption = Select an option
readableInst = Acquire some important knowledge
simulationInst = Animated point of view of the subjects
creditsInst = See who is helping you
changeLanguageInst = Go back to Language Menu

#Simulation Window
process1=Process 1 Instructions
process2=Process 2 Instructions
previous=Previous step
next=Next step
back=Go back
currentprocess1=Process 1 is executing
2blocks1=Process 2 blocks process 1
noblocking=No blocking occurred
currentprocess2=Process 2 is executing
1blocks2=Process 1 blocks process 2
nocritical=No process is in its critical region
critical1=Process 1 is in its critical region
critical2=Process 2 is in its critical region
critical1and2=Both processes are in their critical regions
executing=Current Process Executing Is...
criticalRegion=Current Process In Critical Region Is...
blocking=Is A Process Blocking the Other?
Init=Start
withsimulationMenuTitle=Simulation With Mutual Exclusion
withoutsimulationMenuTitle=Simulation Without Mutual Exclusion
randomsimulationMenuTitle=Random Simulation With Mutual Exclusion
noprocess=Processes have ended execution
withstep0=Imagine two processes are running incrementing a single variable in a shared memory location.\nBoth processes want to read from memory and add one to the value.\nSay the value stored in memory is 95. We expect the first process to read the value from memory to read the value 95,\nadd 1 to it and then store 96. Then, the second process should be able to read value 96, add 1 to it and finally store the\nvalue 97 in memory. But how can the two processes' execution be coordinated so the right values are read and stored?
withstep1=This is done by using mutual exclusion, this is, a mechanism that enables only\none process to read/write from a shared memory location at a given time.\nThe first process is selected by the scheduler and starts executing, creating a local variable.
withstep2=Then, due to mutual exclusion, only one process can be at its critical region at a given time.\nAs process 2 is not in its critical region yet, process 1 is able to proceed and access its critical region by "locking" it.
withstep3=However, the scheduler decides its time to let process 2 execute a little bit. So it starts to run and creates a local variable as well.
withstep4=Then, proces 2 tries to move to the next instruction and enter its critical region.\nBut process 1 is already in its critical region, having previously locked it! So process 2 gets blocked.
withstep5=As process 2 was blocked, it is time for process 1 to run again. It is already in its\ncritical region and reads the content from a shared memory location (address 0xF4D9012C), 95,\nstoring it in the local variable.
withstep6=The scheduler decides it process 2's turn again. It tries to enter its critical region again,\nbut because of mutual exclusion, as process 1 is already at its critical region,\nprocess 2 is blocked again.
withstep7=Process 1 then starts to execute again. It adds 1 to the value in the local variable, which has the value 96 now.
withstep8=Process 2 is selected by the scheduler again and starts executing, but, again, it cannot\nadvance as process 1 is still in its critical region. Process 2 gets blocked.
withstep9=Process 1 executes again and writes 96 to the address 0xF4D9012C.
withstep10=Process 2 is selected by the scheduler again and starts executing, but, again, it cannot\nadvance as process 1 is still in its critical region. Process 2 gets blocked.
withstep11=Then, the scheduler chooses process 1 to execute. Process 1 finally leaves its\ncritical region, "unlocking" it and terminating.
withstep12=As process 1 has already finished its execution and has also left its critical region, process 2\ncan advance! It then enters its critical region and "locks" it.
withstep13=Process 2 reads the value stored in the shared memory location (address 0xF4D9012C),\nwhich is 96, and assigns it to its local variable.
withstep14=Process 2 adds 1 to the value in the local variable, which now holds the value 97.
withstep15=Process 2 writes the value 97 to the shared memory location at address 0xF4D9012C.
withstep16=Process 2 then leaves its critical region and "unlocks" it.
withstep17=It then terminates. After the two processes have executed, we have\nvalue 97 stored in address 0xF4D9012C, as we expected.

withoutstep0=Imagine two processes are running incrementing a single variable in a shared memory location.\nBoth processes want to read from memory and add one to the value.\nSay the value stored in memory is 95. If this was a single sequential program, and the processes functions,\nthe value 95 would be read by the first function, incremented and then stored.\nThe value 96 would then be read by the other function and 97 stored.
withoutstep1=We'll now illustrate how things can go wrong if mutual exclusion is not used when two processes\nrunning share a common memory resource. The first process is selected by the scheduler\nand starts executing, creating a local variable.
withoutstep2=Then, the first process reads the value 95 stored in memory at location 0xF4D9012C and keeps it in a local variable.
withoutstep3=But before it can operate on the value,\nthe scheduler decides it is process' 2 turn, and it is allowed to run.
withoutstep4=The second process reads the unaltered value at address 0xF4D9012C, the same value that the first process read (95).
withoutstep5=The scheduler, liking process 2 better than 1, allows it to continue execution.\nThe second process adds one to the value, outputting 96.
withoutstep6=Finally, it stores the value 96 at memory address 0xF4D9012C and finishes its run.
withoutstep7=The scheduler remembers process 1 exists and gives it processor time, resuming its operation.\nSo, it adds one to the value it read even before process 2 started execution (95).
withoutstep8=Lastly, process 1 stores at memory address 0xF4D9012C the value 96, instead of the desired 97...
withoutstep9=...and terminates. Now, instead of having the expected value 97,\nthe memory location 0xF4D9012C has value 96 stored.
randomstep=This simulation involves two processes that share a common memory and execute\nconcurrently. Both of them have non-terminating while loops. The scheduler selects one of them randomly to execute each cycle.\nThis simulation is using the principles of mutual exclusion.



#Did You Know Window
didYouKnowMenuName = Did you know?
didYouKnowInstructional = Here you will find content about the subjects meant to be taught.\nIt is highly recommended to read before whatchin the simulation
didYouKnowBackButton = Back

#Credits
creditsMenuName = Credits
creditsBackButton = Back

#ChooseMenu
mutualExclusion = Mutal Exclusion
noMutualExclusion = No Mutual Exclusion
random = Random
backButtonChooseSimulationMenu = Back to main menu
chooseMenuTitle = Choose Simulation Mode
onMutualExclusion=Watch a step-by-step simulation of a monocore system that implements mutual exclusion
onNoMutualExclusion=Watch a step-by-step simulation of a monocore system that does not implement mutual exclusion
onRandom=This simulation tries to emulate a scheduler with a seemingly random decision making
